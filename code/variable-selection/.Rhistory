full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb), c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb"))
View(coefs_df)
# Lasso code
lasso <- glmnet(x = as.matrix(x_train), y = as.matrix(y_train), alpha = 1)
# Lasso code
lasso <- glmnet(x = ex.dat[-1], y = ex.dat$y, alpha = 1)
View(lasso)
coef(lasso)
# Lasso code
lasso <- cv.glmnet(x = ex.dat[-1], y = ex.dat$y, alpha = 1)
# Lasso code
lasso <- cv.glmnet(x = ex.dat[-1], y = ex.dat$y)
# Lasso code
lasso <- cv.glmnet(x = ex.dat[-1], y = ex.dat$y, alpha = 1)
?cv.glmnet
?cv.glmnet.raw
?cv.glmnet
# Lasso code
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
View(lasso)
coef(lasso)
coef(lasso, s=lambda.1se)
?cv.glmnet
?glmnet
# Lasso code
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1, intercept = FALSE)
coef(lasso)
# Lasso code
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1, intercept = TRUE)
coef(lasso)
# Lasso code
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(coef(model_list[[i]])) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, lasso), c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb", "lasso"))
class(coef(lasso))
list(coef(lasso))
matrix(coef(lasso))
data.frame(coef(lasso))
as.data.frame(coef(lasso))
data.frame(as.matrix(coef(lasso)))
coef(lasso)
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(model_list[[i]]$coefficients) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb), c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb"))
as.data.frame(as.matrix(coef(lasso)))
length(as.data.frame(as.matrix(coef(lasso))))
class(as.data.frame(as.matrix(coef(lasso))))
as.data.frame(as.matrix(coef(lasso)))[-2]
as.data.frame(as.matrix(coef(lasso)))[-2,]
as.data.frame(as.matrix(coef(lasso)))[-2]
as.data.frame(as.matrix(coef(lasso)))[-2,1]
as.data.frame(as.matrix(coef(lasso)))[1,-2]
as.data.frame(as.matrix(coef(lasso)))[-2,0]
as.data.frame(as.matrix(coef(lasso)))[-2,1]
as.data.frame(as.matrix(coef(lasso)))[-2,1]
l <- as.data.frame(as.matrix(coef(lasso)))[-2]
View(l)
l <- as.data.frame(as.matrix(coef(lasso)))[-2,]
l <- as.data.frame(as.matrix(coef(lasso)))
l <- as.data.frame(as.matrix(coef(lasso)))[-2,]
colnames(l) <- names(coef(fm))
coef(lasso)
coef(fm)
as.data.frame(as.matrix(coef(lasso)))[-2:3,]
as.data.frame(as.matrix(coef(lasso)))[-2:-3,]
as.data.frame(as.matrix(coef(lasso))[-2:-3,])
lasso_coefs$coefficients <- as.data.frame(as.matrix(coef(lasso))[-2:-3,])
lasso_coefs <- as.data.frame(as.matrix(coef(lasso))[-2:-3,])
lasso_coefs$coefficients <- as.data.frame(as.matrix(coef(lasso))[-2:-3,])
View(lasso_coefs)
lasso_coefs <- as.data.frame(as.matrix(coef(lasso))[-2:-3,])
?as.data.frame
lasso_coefs <- as.data.frame(as.matrix(coef(lasso))[-2:-3,], col.names = c("coefficients"))
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_coefs <- as.data.frame(as.matrix(coef(lasso))[-2:-3,], col.names = c("coefficients"))
colnames(lasso_coefs) <- c("coefficients")
lasso_coefs <- as.data.frame(as.matrix(coef(lasso))[-2:-3,], `colnames<-`(c("coefficients")))
# Lasso code
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_coefs <- as.data.frame(as.matrix(coef(lasso))[-2:-3,])
colnames(lasso_coefs) <- c("coefficients")
# Lasso code
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_c <- as.data.frame(as.matrix(coef(lasso))[-2:-3,])
colnames(lasso_c) <- c("coefficients")
View(lasso_c)
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, lasso_c), c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb", "lasso"))
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(model_list[[i]]$coefficients) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, lasso_c), c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb", "lasso"))
list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, lasso_c)
list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, lasso_c)[[3]]$coefficients
list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, lasso_c)[[9]]$coefficients
list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, lasso_c)[[10]]$coefficients
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(model_list[[i]]$coefficients) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb), c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb"))
coefs_df <- left_join(coefs_df, lasso_c)
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_c <- as.data.frame(as.matrix(coef(lasso))[-2:-3,])
colnames(lasso_c) <- c("coefficients")
list(as.matrix(coef(lasso))[-2:-3,])
colnames(list(as.matrix(coef(lasso))[-2:-3,]))
test <-  list(as.matrix(coef(lasso))[-2:-3,])
View(test)
View(test)
test$x2
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_c <- list(as.matrix(coef(lasso))[-2:-3,])
colnames(lasso_c) <- c("lasso")
lasso_c$betas <- row.names(lasso_c)
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_c <- list(as.matrix(coef(lasso))[-2:-3,])
colnames(lasso_c) <- c("lasso")
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_c <- list(as.matrix(coef(lasso))[-2:-3,])
colnames(lasso_c) <- c("coefficients")
# Lasso code
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_c <- list(as.matrix(coef(lasso))[-2:-3,])
lasso_c$betas <- row.names(lasso_c)
colnames(lasso_c) <- c("lasso", "betas")
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_c <- list(as.matrix(coef(lasso))[-2:-3,])
# Lasso code
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_c <- list(as.matrix(coef(lasso))[-2:-3,])
lasso_c$betas <- row.names(lasso_c)
# Lasso code
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_c <- list(as.matrix(coef(lasso))[-2:-3,])
lasso_c$betas <- row.names(lasso_c)
# Lasso code
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_c <- data.frame(as.matrix(coef(lasso))[-2:-3,])
lasso_c$betas <- row.names(lasso_c)
# Lasso code
lasso <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 1)
lasso_c <- data.frame(as.matrix(coef(lasso))[-2:-3,])
colnames(lasso_c) <- c("lasso")
lasso_c$betas <- row.names(lasso_c)
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(model_list[[i]]$coefficients) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb), c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb"))
coefs_df <- left_join(coefs_df, lasso_c, by = "betas")
# Ridge code
ridge <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 0)
ridge_c <- data.frame(as.matrix(coef(ridge))[-2:-3,]) #turns coefs into usable dataframe
colnames(ridge_c) <- c("ridge")
ridge_c$betas <- row.names(ridge_c)
View(ridge_c)
# Ridge model for dealing with multicollinearity
ridge <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 0)
ridge_c <- data.frame(as.matrix(coef(ridge))[-2:-3,]) #turns coefs into usable dataframe
colnames(ridge_c) <- c("ridge")
ridge_c$betas <- row.names(ridge_c)
# Elastic Net model for multicollinearity and variable selection
enet <- cv.glmnet(x = model.matrix(y~., data = ex.dat), y = ex.dat$y, alpha = 0.8) #small alpha is not needed since small multicollinearity
enet_c <- data.frame(as.matrix(coef(enet))[-2:-3,]) #turns coefs into usable dataframe
colnames(enet_c) <- c("elastic.net")
enet_c$betas <- row.names(enet_c)
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(model_list[[i]]$coefficients) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb), c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb"))
#manually add lasso, ridge, and enet coefs
coefs_df <- left_join(coefs_df, lasso_c, by = "betas")
coefs_df <- left_join(coefs_df, ridge_c, by = "betas")
coefs_df <- left_join(coefs_df, enet_c, by = "betas")
?left_join
source('~/NSFREU/reu-2021/code/variable-selection/monte-carlo.r', echo=TRUE)
coef(mcp)
class(mcp)
mcp
lasso
lasso$lambda.1se
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(model_list[[i]]$coefficients) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, mcp, scad),
c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb", "mcp", "scad"))
#manually add lasso, ridge, and enet coefs
coefs_df <- left_join(coefs_df, lasso_c, by = "betas")
coefs_df <- left_join(coefs_df, ridge_c, by = "betas")
coefs_df <- left_join(coefs_df, enet_c, by = "betas")
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(model_list[[i]]$coefficients) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, mcp, scad),
c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb", "mcp", "scad"))
#manually add lasso, ridge, and enet coefs
coefs_df <- left_join(coefs_df, lasso_c, by = "betas")
coefs_df <- left_join(coefs_df, ridge_c, by = "betas")
coefs_df <- left_join(coefs_df, enet_c, by = "betas")
mcp
coef(mcp)
mcp$coefficients
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(coef(model_list[[i]])) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, mcp, scad),
c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb", "mcp", "scad"))
#manually add lasso, ridge, and enet coefs
coefs_df <- left_join(coefs_df, lasso_c, by = "betas")
coefs_df <- left_join(coefs_df, ridge_c, by = "betas")
coefs_df <- left_join(coefs_df, enet_c, by = "betas")
class(scad)
clasS(mcp)
class(mcp)
mcp_c
coef(lasso)
source('~/NSFREU/reu-2021/code/variable-selection/monte-carlo.r', echo=TRUE)
R.version
model.matrix(y~., data = ex.dat)
matrix(ex.dat[,-1])
ex.dat
matrix(ex.dat)[,-1]
ex.dat[,-1]
matrix(ex.dat[,-1])
# Elastic Net model for multicollinearity and variable selection
enet <- cv.glmnet(x = matrix(ex.dat[,-1]), y = ex.dat$y, alpha = 0.8) #small alpha is not needed since small multicollinearity
# Elastic Net model for multicollinearity and variable selection
enet <- cv.glmnet(x = model.matrix(ex.dat[,-1]), y = ex.dat$y, alpha = 0.8) #small alpha is not needed since small multicollinearity
# Elastic Net model for multicollinearity and variable selection
enet <- cv.glmnet(x = matrix(ex.dat[,-1]), y = ex.dat$y, alpha = 0.8) #small alpha is not needed since small multicollinearity
model.matrix(y~., data = ex.dat)
model.matrix(y~.-x0, data = ex.dat)
# Elastic Net model for multicollinearity and variable selection
enet <- cv.glmnet(x = model.matrix(y~.-x0, data = ex.dat), y = ex.dat$y, alpha = 0.8) #small alpha is not needed since small multicollinearity
coef(enet)
?model.matrix
# Elastic Net model for multicollinearity and variable selection
enet <- cv.glmnet(x = as.matrix(ex.dat[,-1]), y = ex.dat$y, alpha = 0.8) #small alpha is not needed since small multicollinearity
coef(enet)
# Elastic Net model for multicollinearity and variable selection
enet <- cv.glmnet(x = as.matrix(ex.dat[,-1]), y = ex.dat$y, alpha = 0.8) #small alpha is not needed since small multicollinearity
enet_c <- data.frame(as.matrix(coef(enet))) #turns coefs into usable dataframe
colnames(enet_c) <- c("elastic.net")
enet_c$betas <- row.names(enet_c)
enet_c
# Lasso model for variable selection
library(glmnet)
lasso <- cv.glmnet(x = as.matrix(ex.dat[,-1]), y = ex.dat$y, alpha = 1)
lasso_c <- data.frame(as.matrix(coef(lasso))) #turns coefs into usable dataframe
colnames(lasso_c) <- c("lasso")
lasso_c$betas <- row.names(lasso_c)
# Ridge model for dealing with multicollinearity
ridge <- cv.glmnet(x = as.matrix(ex.dat[,-1]), y = ex.dat$y, alpha = 0)
ridge_c <- data.frame(as.matrix(coef(ridge))) #turns coefs into usable dataframe
colnames(ridge_c) <- c("ridge")
ridge_c$betas <- row.names(ridge_c)
# Elastic Net model for multicollinearity and variable selection
enet <- cv.glmnet(x = as.matrix(ex.dat[,-1]), y = ex.dat$y, alpha = 0.8) #small alpha is not needed since small multicollinearity
enet_c <- data.frame(as.matrix(coef(enet))) #turns coefs into usable dataframe
colnames(enet_c) <- c("elastic.net")
enet_c$betas <- row.names(enet_c)
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(coef(model_list[[i]])) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, mcp, scad),
c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb", "mcp", "scad"))
#manually add lasso, ridge, and enet coefs
coefs_df <- left_join(coefs_df, lasso_c, by = "betas")
coefs_df <- left_join(coefs_df, ridge_c, by = "betas")
coefs_df <- left_join(coefs_df, enet_c, by = "betas")
as.data.frame(coef(enet))
as.data.frame(as.matrix(coef(fm)))
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(as.matrix(coef(model_list[[i]]))) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, mcp, scad, lasso),
c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb", "mcp", "scad", "lasso"))
# Gabe's probably slower method to put models into a dataframe
library(dplyr)
multi.merge <-function(model_list, col_names){ #takes input of list of lm models, and vector of column names
for (i in 1:length(model_list)){
model_list[[i]] <- data.frame(as.matrix(coef(model_list[[i]]))) #turns lm model class into dataframe of coefficients
model_list[[i]]$betas <- row.names(model_list[[i]]) #adds column of beta coefficient names
}
# ugly code to rearrange order of beta column and full model column
full_df <- model_list[[1]]
full_df <- full_df[-1]
full_df$fm <- model_list[[1]][[1]]
for (i in 2:length(model_list)){
full_df <- left_join(full_df, model_list[[i]], by = "betas") #joins code together by beta coefficient name
}
full_df[is.na(full_df)] <- 0
colnames(full_df) <- c("betas", col_names) #renames columns according to what was input to the function
return(full_df)
}
coefs_df <- multi.merge(list(fm, af, bf, ab, bb, asf, bsf, asb, bsb, mcp, scad, lasso, ridge, enet),
c("fm", "af", "bf", "ab", "bb", "asf", "bsf", "asb", "bsb", "mcp", "scad", "lasso", "ridge", "elastic_net"))
source('~/NSFREU/reu-2021/code/variable-selection/monte-carlo.r', echo=TRUE)
source('~/github/reu-2021/code/variable-selection/monte-carlo.r', echo=TRUE)
mcp
coef(mcp)
coef(mcp, lambda = mcp$lambda.min)
coef(lasso)
coef(ridge)
coef(enet)
models <- list(fm = fm, nm = nm, af = af, bf = bf, ab = ab, bb = bb, asf = asf, bsf = bsf,
asb = asb, bsb = bsb, ridge = ridge
scad = scad, mcp = mcp)
row.names <- c("(Intercept)", paste("x", 1:10, sep = ""))
get.coef <- function(model)
{
coef_values <- unlist(lapply(row.names, function(predictor) coef(model)[predictor]))
}
df <- data.frame(lapply(models, get.coef), row.names = row.names)
df[df == 0] <- NA
coef(ridge)["x1"]
coef(ridge)
coef(mcp)["x1"]
coef(ridge)["x1"]
coef(ridge)
coef(mcp)
source('~/github/reu-2021/code/variable-selection/monte-carlo.r', echo=TRUE)
source('~/github/reu-2021/code/variable-selection/monte-carlo.r', echo=TRUE)
?cv.glmnet
coef(enet)
coef(mcp)
unlist(enet[, 2])
unlist(enet[1])
unlist(coef(enet)[, 2])
unlist(coef(enet)[, 1])
unlist(coef(enet)[, 1])[-2]
unlist(list(NA, 2, 3))
scad <- cv.ncvreg(X = ex.dat[, -1], y = ex.dat$y, penalty = "SCAD", intercept = FALSE)
#scad_c <- coef(scad, lambda = scad$lambda.min)
mcp <- cv.ncvreg(X = ex.dat[, -1], y = ex.dat$y, intercept = FALSE)
coef(mcp)
?cv.ncvreg
?ncvreg
